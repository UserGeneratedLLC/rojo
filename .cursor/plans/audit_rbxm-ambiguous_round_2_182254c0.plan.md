---
name: Audit rbxm-ambiguous round 2
overview: "Fix 7 issues found during audit of the rbxm-ambiguous branch: 2 critical (roundtrip test can't detect lost duplicates, raw instance name in directory path), 2 moderate (case-sensitive duplicate detection, error-as-flow-control), test assertion gaps, and dead code cleanup."
todos:
  - id: fix1-roundtrip-test
    content: Fix compare_children in syncback_roundtrip.rs to use Vec-based comparison that detects lost duplicate instances
    status: completed
  - id: fix2-raw-name-path
    content: Replace inline standalone-to-directory conversion in syncback_update_existing_instance with call to convert_standalone_script_to_directory
    status: completed
  - id: fix3-case-insensitive
    content: Change project.rs child map to use lowercased keys for case-insensitive duplicate detection
    status: completed
  - id: fix4-typed-error
    content: Define DuplicateChildrenError in dir.rs, match on it in mod.rs rbxm fallback catch
    status: completed
  - id: fix5-test-assertions
    content: "Add meaningful assertions to 6 tests: ambiguous_dedup_collision, windows_invalid_chars, expansion_resolved, project_node_parent, twoway_add_duplicate, twoway_rename_duplicate"
    status: completed
  - id: fix6-dead-code
    content: Remove filter_duplicate_children passthrough and update 3 call sites in api.rs
    status: completed
  - id: fix7-minor
    content: Remove unused fixture_gen functions, fix !is_some() style, remove unused Variant import
    status: completed
  - id: fix8-macos-ci
    content: Add macOS ignore annotation to ref_properties serve test (kqueue double-WRITE event causes spurious Rojo_* attribute updates)
    status: completed
  - id: run-ci
    content: "Run full CI: cargo clippy, cargo test --lib, cargo test --test end_to_end"
    status: completed
isProject: false
---

# Audit: rbxm-ambiguous Branch -- Round 2 Fixes

> This plan was generated by `/audit` from a Plan-mode session.
> Refer to `.cursor/rules/atlas.mdc` for full project standards.

## Standards

These standards govern every fix in this plan. An implementer MUST read `.cursor/rules/atlas.mdc` before starting.

### Round-Trip Identity (from `atlas.mdc` Quality Standard)

Syncback (or two-way sync) writes a directory tree. Building an rbxl from that directory tree and forward-syncing it back must produce a **bit-identical instance tree** -- same names, same classes, same properties, same hierarchy, same ref targets. Any deviation is a bug.

### CLI Syncback Parity (from `atlas.mdc` Two-Way Sync Strategy)

Plugin-based sync must produce **exactly the same filesystem output** that `atlas syncback` would give for the same input. Byte-for-byte identical files, identical directory structures, identical naming. Any divergence is a bug until proven otherwise.

### Code Quality (from `atlas.mdc` Code Quality Standard)

DRY code that is easy to reason about and hard to get wrong. The same slugify/dedup/meta-update pattern should not be copy-pasted across files. Small refactors (2-3 call sites) are included as fixes. Major rewrites (10+ call sites) are deferred.

## Context

Audited the `rbxm-ambiguous` branch (6 commits, 113 files changed) which implements the ambiguous rbxm container system. The prior audit (`.cursor/plans/audit_ambiguous_container_fixes_6a267f1f.plan.md`) was fully applied. This second audit found: 2 critical bugs (roundtrip test blind to duplicates, raw instance name in path creation), 2 moderate issues (case-insensitive detection gap, overly-broad error catch), 6 tests with empty/insufficient assertions, and dead code.

## Fixes

### Fix 1: Roundtrip test comparison cannot detect lost duplicate instances

- **Status:** Approved
- **Finding:** Step 2a: Round-trip identity tracing
- **Files:** `tests/tests/syncback_roundtrip.rs`
- **Problem:** `compare_children` (lines 106-172) uses `HashMap<&str, &Instance>` keyed by instance name. `HashMap::insert` silently overwrites when two children share a name. The `ambiguous_container_roundtrip` test passes even if all duplicate instances are lost during roundtrip -- the primary failure mode it was written to catch.
Specifically:
  - Line 113: `map_a.insert(&child.name, child)` overwrites on duplicate names
  - Lines 124-125: `HashSet` from map keys deduplicates names
  - Lines 154-161: `children().iter().find(|..| name == Some(name))` always finds the FIRST match, never the second duplicate
- **Solution:** Replace `HashMap<&str, &Instance>` with a `Vec<(&str, &Instance)>` sorted by name. The comparison should:
  1. Assert `children_a.len() == children_b.len()` (catches count mismatches immediately)
  2. Build sorted vectors: `let mut pairs_a: Vec<_> = children_a.iter().filter_map(|r| dom_a.get_by_ref(r).map(|i| (i.name.as_str(), r))).collect(); pairs_a.sort_by_key(|(name, _)| *name);`
  3. Iterate both vectors in lockstep, comparing name + class + properties at each index
  4. For duplicate names, compare in order (position-based matching)
  This handles the case where `[Dup, Dup, Script]` roundtrips to `[Dup, Script]` -- the count check at step 1 catches it.
- **Risk:** Low -- test-only change. No production code modified.
- **Verify round-trip:** The test itself IS the round-trip verification. After fixing, temporarily break the rbxm serialization to confirm the test fails.
- **Verify syncback parity:** N/A
- **Tests required:**
  - Modify `compare_children` function to use Vec-based comparison (Rust integration test)
  - Verify `ambiguous_container_roundtrip` still passes with the fixed comparison

### Fix 2: Raw instance name used as directory path in standalone-to-directory conversion

- **Status:** Approved
- **Finding:** Step 4: Server-side processing audit / Step 11f: File-to-folder transitions
- **Files:** `src/web/api.rs`
- **Problem:** `syncback_update_existing_instance` lines 1102-1151 have an inline standalone-to-directory conversion that uses `added.name.as_str()` (raw instance name, possibly containing `?`, `*`, `<`, `>`, etc.) as a directory name. If instance is "What?Script" and existing file is `What_Script.server.luau`, this creates `parent/What?Script/` -- invalid on Windows.
This block is also a code duplication of `convert_standalone_script_to_directory` (lines 1234-1314) but without safe path derivation and without adjacent meta file migration.
- **Solution:** Replace the inline conversion at lines 1102-1151 with a call to `convert_standalone_script_to_directory`:

```rust
  // Was:
  let script_name = added.name.as_str();
  let parent_dir = existing_path.parent().unwrap_or(existing_path);
  let new_dir = parent_dir.join(script_name);
  // ... 45 lines of inline conversion ...
  
  // Replace with:
  let parent_dir = existing_path.parent().unwrap_or(existing_path);
  let new_dir = self.convert_standalone_script_to_directory(
      existing_path,
      &added.name,
      &class_name,
      parent_dir,
  )?;
  

```

  The `convert_standalone_script_to_directory` helper already:

- Uses `dir_name_from_script_path(standalone_path)` for safe path derivation
- Creates the directory and init file
- Removes the old standalone file
- Migrates adjacent meta files
- **Risk:** Low-Medium. The helper is already tested. The old inline code was missing meta migration, so this is strictly an improvement.
- **Verify round-trip:** Create a test that adds a child to an instance with a forbidden-char name via `/api/write`, verify the directory uses the slugified name.
- **Verify syncback parity:** The helper uses the same path derivation as CLI syncback.
- **Tests required:**
  - Add a two-way sync test: add child to instance with forbidden-char name, verify directory uses slugified name (Rust integration test)

### Fix 3: project.rs case-sensitive HashMap misses case-only duplicates

- **Status:** Approved
- **Finding:** Step 11k: Edge cases
- **Files:** `src/snapshot_middleware/project.rs`
- **Problem:** Lines 587-604: `new_child_map` uses `HashMap<&String, Instance>` with exact-case keys. "Script" and "script" under a ProjectNode are stored as separate entries. The `.is_some()` check at line 592 never fires for case-only collisions. The `retain` filter at lines 628-629 uses `to_lowercase` but `new_duplicate_names` was never populated.
- **Solution:** Use `has_duplicate_children` (from `src/syncback/mod.rs`) as a pre-check, consistent with how `dir.rs` handles duplicates. Before building the child maps:

```rust
  // Pre-check for case-insensitive duplicates
  if crate::syncback::has_duplicate_children(snapshot.new_tree(), new_inst.referent()) {
      let parent_path = inst_path(snapshot.new_tree(), new_inst.referent());
      log::warn!(
          "Skipping duplicate-named children under ProjectNode '{}' -- \
           cannot create rbxm container for project-file instances.",
          parent_path,
      );
      // Build child maps without duplicates
      // ... use case-insensitive HashSet for detection ...
  }
  

```

  Alternatively, change the child map key to be lowercased to match the detection sensitivity:

```rust
  let mut new_child_map: HashMap<String, &Instance> = HashMap::new();
  for child_ref in new_inst.children() {
      let child = snapshot.get_new_instance(*child_ref).expect("...");
      let key = child.name.to_lowercase();
      if new_child_map.insert(key, child).is_some() {
          // Now correctly detects "Script" vs "script"
          new_duplicate_names.insert(child.name.to_lowercase());
      }
  }
  

```

  The second approach (lowercased keys) is simpler and self-contained.

- **Risk:** Low. Only affects ProjectNode syncback with case-only duplicate children -- extremely rare.
- **Verify round-trip:** N/A (ProjectNode children are managed by project file)
- **Verify syncback parity:** Run syncback on project with case-only duplicate children under a service, verify warning logged.
- **Tests required:**
  - Unit test: ProjectNode service with "Script" and "script" children, verify both detected and skipped (Rust unit test)

### Fix 4: Any dir-middleware error triggers rbxm fallback (not just duplicate detection)

- **Status:** Approved
- **Finding:** Step 2a: Round-trip identity tracing
- **Files:** `src/snapshot_middleware/dir.rs`, `src/syncback/mod.rs`
- **Problem:** `mod.rs` line 573: `Err(err) if is_dir_middleware(middleware)` catches ALL errors from dir-middleware syncback. A genuine I/O error, permission denied, or corrupted child during directory processing would silently fall back to rbxm container instead of being reported.
- **Solution:** Define a typed error in `dir.rs`:

```rust
  #[derive(Debug, thiserror::Error)]
  #[error("directory has duplicate-named children at {path}")]
  pub struct DuplicateChildrenError {
      pub path: String,
  }
  

```

  In `syncback_dir_no_meta`, return this typed error instead of `anyhow::bail!`:

```rust
  if has_duplicate_children(snapshot.new_tree(), snapshot.new) {
      let inst_path = inst_path(snapshot.new_tree(), snapshot.new);
      return Err(DuplicateChildrenError { path: inst_path }.into());
  }
  

```

  In `mod.rs`, match on the typed error:

```rust
  Err(err) if is_dir_middleware(middleware) && err.downcast_ref::<DuplicateChildrenError>().is_some() => {
      // rbxm fallback logic...
  }
  

```

  Genuine errors fall through to the normal `Err(err) => bail!(...)` path.

- **Risk:** Low. Changes the error type but not the control flow for the duplicate case.
- **Verify round-trip:** The duplicate-detection path produces the same result.
- **Verify syncback parity:** N/A
- **Tests required:**
  - Existing syncback tests cover the duplicate case (no new test needed)
  - Verify that non-duplicate dir errors are NOT caught by the fallback (could add a unit test that simulates a dir-middleware error and confirms it propagates)

### Fix 5: Add meaningful assertions to 6 tests with empty/insufficient checks

- **Status:** Approved
- **Finding:** Step 11i: Syncback idempotency / Test coverage
- **Files:** `tests/tests/syncback.rs`, `tests/tests/two_way_sync.rs`
- **Problem:** 6 tests have empty assertion lists or no filesystem checks:
  - `ambiguous_dedup_collision` (`[]`)
  - `ambiguous_windows_invalid_chars` (`[]`)
  - `ambiguous_expansion_resolved` (`[]`)
  - `ambiguous_project_node_parent` (`[]`)
  - `twoway_add_duplicate_names_handled` (only server-alive check)
  - `twoway_rename_creates_duplicate_no_crash` (only server-alive check)
- **Solution:**
For syncback tests, populate the file assertion lists. Run each test individually, inspect the snapshot output, and add the correct file paths:
  - `ambiguous_dedup_collision`: Expected files should include the dedup-suffixed rbxm (e.g., `src/Test~1.rbxm`, `src/Test~1.meta.json5`) plus the normal directory `src/Test/`. Run the test and inspect actual output to determine the exact file list.
  - `ambiguous_windows_invalid_chars`: Expected files should include the slugified rbxm name and meta file.
  - `ambiguous_expansion_resolved`: Expected files should assert the rbxm is GONE and individual child directories/files are present. This is the most critical: assert `src/Parent/` is a directory, `src/Parent/Child/` exists, `src/Parent/ChildB/` exists, and `src/Parent.rbxm` does NOT exist.
  - `ambiguous_project_node_parent`: Expected files should include unique children that were synced (not the duplicates).
  For two-way sync tests, add filesystem checks:
  - `twoway_add_duplicate_names_handled`: After adding two "Dup" instances, verify what the server produced (either two dedup-named files or an rbxm container).
  - `twoway_rename_creates_duplicate_no_crash`: After rename, verify filesystem state (rbxm container created or dedup-named files).
- **Risk:** None (test-only changes)
- **Verify round-trip:** The tests themselves verify correctness.
- **Verify syncback parity:** N/A
- **Tests required:** This IS the test fix.

### Fix 6: Remove dead `filter_duplicate_children` passthrough

- **Status:** Approved
- **Finding:** Step 12: Static analysis
- **Files:** `src/web/api.rs`
- **Problem:** `filter_duplicate_children` (lines 1614-1621) is now a passthrough returning all children. Called from 3 places (lines 1157, 1193, 1757) with unused parameters `_parent_path` and `_stats`.
- **Solution:** Remove the function entirely. At each call site, replace:

```rust
  let unique_children = self.filter_duplicate_children(&added.children, &inst_path, stats);
  

```

  with:

```rust
  let children: Vec<&_> = added.children.iter().collect();
  

```

  Or, even better, refactor callers to work with `&[AddedInstance]` directly instead of `Vec<&AddedInstance>`.

- **Risk:** None. Dead code removal.
- **Verify round-trip:** Run existing test suite.
- **Verify syncback parity:** N/A
- **Tests required:** Verify existing tests pass (no new tests needed)

### Fix 7: Minor cleanup (clippy warnings + style)

- **Status:** Approved
- **Finding:** Step 12: Static analysis
- **Files:** `tests/rojo_test/fixture_gen.rs`, `src/snapshot/tree.rs`, `src/web/api.rs` (test module)
- **Problem:**
  1. `fixture_gen.rs`: Unused `server_script` and `object_value` functions (clippy dead_code warnings)
  2. `tree.rs:296`: `!parent.is_some()` should be `parent.is_none()` (idiomatic)
  3. `api.rs` test module: Unused import `types::Variant` (clippy warning)
- **Solution:**
  1. Remove `server_script` and `object_value` from `fixture_gen.rs` (or add `#[allow(dead_code)]` if they're intended for future use)
  2. Change `!parent.is_some()` to `parent.is_none()` at tree.rs:296
  3. Remove `use types::Variant` from the test module in api.rs
- **Risk:** None.
- **Verify round-trip:** N/A
- **Verify syncback parity:** N/A
- **Tests required:** `cargo clippy --all-targets` produces no new warnings for changed files.

### Fix 8: macOS CI failure -- `ref_properties` serve test

- **Status:** Approved
- **Finding:** CI failure on macOS (GitHub Actions)
- **Files:** `tests/tests/serve.rs`
- **Problem:** On macOS, kqueue delivers a duplicate WRITE event for the `fs::write` to `ModelTarget.model.json5`. The first event produces the expected patch (1 added, 2 updated). The second event re-snapshots and finds that `apply_patch_set` stripped `Rojo_Id`, `Rojo_Target_`*, `Rojo_Ref_`* attributes from the tree (patch_apply.rs:171-202), but the on-disk file still has them. This produces 3 spurious Attribute updates that break the snapshot assertion.
This is the same issue as `ref_properties_remove` (lines 475-481), which already has `#[cfg_attr(target_os = "macos", ignore)]`. The Rojo_* attribute stripping is existing behavior (unchanged by this branch). The timing difference is caused by `handle_vfs_event` taking slightly longer in this branch (additional logging, ref_path_index, recovery scheduling), so the second kqueue event arrives after the `try_recv` drain window closes.
- **Solution:** Add `#[cfg_attr(target_os = "macos", ignore)]` to the `ref_properties` test (line 418-419) with the same comment pattern as `ref_properties_remove`:

```rust
  // On macOS, kqueue delivers an extra WRITE event for the same fs::write,
  // which triggers a second re-snapshot. Because apply_patch_set strips
  // Rojo_* ref attributes from the tree (they're transport-only), the second
  // snapshot detects them as new changes, producing spurious updates.
  #[test]
  #[cfg_attr(target_os = "macos", ignore)]
  fn ref_properties() {
  

```

- **Risk:** None. The test still runs on Windows and Linux CI. The macOS-specific behavior is correct (kqueue is more thorough), just not what the snapshot was captured against.
- **Verify round-trip:** N/A (test infrastructure)
- **Verify syncback parity:** N/A
- **Tests required:** Verify the test passes on Windows/Linux CI and is correctly skipped on macOS.

## Skipped Fixes

None -- all identified fixes were approved.

## Accepted Limitations

- **Limitation:** Plugin reconnection hydration may mismatch duplicate-named instances
- **Scenario:** When plugin reconnects after disconnect, `diff.lua` matches Studio instances to server tree by Name+ClassName. For duplicate-named instances, ordered matching may pair the wrong sibling.
- **User decision:** Accepted for this release (carried from prior audit)
- **Mitigation:** The next full sync corrects any mismatch. Phase 2 (N-to-M property-based matcher) will address this.

## Deferred Refactors

- **Consolidate rbxm container detection logic**: `find_rbxm_container` is called from `api.rs`, `change_processor.rs`, and `syncback/mod.rs`. Consider a higher-level API returning an enum of `NotInContainer | IsContainer(path) | InsideContainer(container_ref, path)`. (Flagged in prior audit, still relevant.)
- `**encodeInstance.lua` dead helpers**: `findDuplicateNames`, `hasDuplicateSiblings`, `isPathUnique` are still defined for `Log.debug` calls but never used for filtering. Could be stripped entirely to reduce plugin complexity. (Evaluate after Phase 2.)

## Test Plan

### Rust Integration Tests (`tests/tests/`)

- Fix `compare_children` in `syncback_roundtrip.rs` to use Vec-based comparison that handles duplicate names (Fix 1)
- Add meaningful file assertions to `ambiguous_dedup_collision`, `ambiguous_windows_invalid_chars`, `ambiguous_expansion_resolved`, `ambiguous_project_node_parent` in `syncback.rs` (Fix 5)
- Add filesystem assertions to `twoway_add_duplicate_names_handled` and `twoway_rename_creates_duplicate_no_crash` in `two_way_sync.rs` (Fix 5)
- Add two-way sync test: add child to instance with forbidden-char name, verify slugified directory (Fix 2)

### Rust Unit Tests (`#[cfg(test)]` blocks)

- ProjectNode service with case-only duplicate children ("Script" vs "script"), verify detected and skipped (Fix 3)

### Static Analysis

- `cargo clippy --all-targets` produces 0 new warnings in modified files (Fix 7)
- `cargo test --lib` passes all unit tests
- `cargo test --test end_to_end` passes all integration tests

## Test Rules

### For bugs found and fixed

Every bug fix MUST have a test that:

1. Would have **FAILED** before the fix
2. **PASSES** after the fix
3. Prevents the bug from regressing

### For missing coverage identified

For each "missing test coverage" gap:

1. Write the test
2. Verify it passes against the current implementation
3. If it fails, investigate -- it may have found another bug

### Scope: test every affected layer

For each finding, determine which test layers are affected and write tests in ALL of them.

## Final Step: Run CI

After ALL fixes and tests are implemented, run the `/ci` command to execute the full CI pipeline. Every fix must pass CI before the plan is considered complete.