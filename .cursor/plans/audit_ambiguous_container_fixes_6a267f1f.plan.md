---
name: Audit Ambiguous Container Fixes
overview: Fix failing Lua spec tests, remove dead code from duplicate-skip removal, cache redundant find_rbxm_container call, add missing test entry, and change ProjectNode duplicate handling from bail to warn-and-skip.
todos:
  - id: fix1-lua-tests
    content: Update encodeInstance.spec.lua and diff.spec.lua to assert new behavior (encode all children, no duplicate skipping)
    status: completed
  - id: fix2-dead-code
    content: "Remove dead code: skippedDuplicateCount in encodeInstance.lua, findDuplicateNames in diff.lua, is_tree_path_unique_with_cache and duplicate_siblings_cache in api.rs"
    status: completed
  - id: fix3-cache-call
    content: Cache find_rbxm_container result in change_processor.rs to avoid redundant ancestor walk
    status: completed
  - id: fix4-dedup-test
    content: Add ambiguous_dedup_collision test entry to syncback_tests! macro and accept snapshot
    status: completed
  - id: fix5-projectnode
    content: Change project.rs to warn-and-skip duplicate children under ProjectNode/service parents instead of bailing. Add test fixture.
    status: completed
  - id: verify-ci
    content: Run full test suite (cargo test --lib, cargo test --test end_to_end, cargo clippy) and verify all passes
    status: completed
isProject: false
---

# Audit: Ambiguous rbxm Container System Fixes

> This plan was generated by `/audit` from a Plan-mode session.
> Refer to `.cursor/rules/atlas.mdc` for full project standards.

## Standards

These standards govern every fix in this plan. An implementer MUST read `.cursor/rules/atlas.mdc` before starting.

### Round-Trip Identity (from `atlas.mdc` Quality Standard)

Syncback (or two-way sync) writes a directory tree. Building an rbxl from that directory tree and forward-syncing it back must produce a **bit-identical instance tree** -- same names, same classes, same properties, same hierarchy, same ref targets. Any deviation is a bug.

### CLI Syncback Parity (from `atlas.mdc` Two-Way Sync Strategy)

Plugin-based sync must produce **exactly the same filesystem output** that `atlas syncback` would give for the same input. Byte-for-byte identical files, identical directory structures, identical naming. Any divergence is a bug until proven otherwise.

### Code Quality (from `atlas.mdc` Code Quality Standard)

DRY code that is easy to reason about and hard to get wrong. The same slugify/dedup/meta-update pattern should not be copy-pasted across files. Small refactors (2-3 call sites) are included as fixes. Major rewrites (10+ call sites) are deferred.

## Context

Audited the `rbxm-ambiguous` branch which implements the ambiguous rbxm container system: when an instance has duplicate-named children, the parent is serialized as a single `.rbxm` file instead of skipping duplicates. Changes span Rust server code (syncback, change_processor, api, metadata, tree, snapshot middleware) and Lua plugin code (encodeInstance, diff).

The implementation is functionally correct for the core syncback and two-way sync paths. The audit found: 2 failing Lua spec tests, dead code from the duplicate-skip removal, a redundant function call, a missing test entry, and a ProjectNode handling issue.

## Fixes

### Fix 1: Update Lua spec tests for new duplicate behavior

- **Status:** Approved
- **Finding:** Step 3: Plugin-side encoding audit
- **Files:** `plugin/src/ChangeBatcher/encodeInstance.spec.lua`, `plugin/src/Reconciler/diff.spec.lua`
- **Problem:** Two spec files have tests asserting the OLD duplicate-skipping behavior:
  - `encodeInstance.spec.lua` line 235: "should skip children with duplicate names" expects only 1 child when duplicates exist
  - `diff.spec.lua` lines 279-310: "should skip real DOM children with duplicate names" expects empty `removed`
  - `diff.spec.lua` lines 312-345: "should skip virtual children with duplicate names" expects empty `added`
- **Solution:** Update all three tests to assert the NEW behavior:
  - `encodeInstance.spec.lua`: Change test to "should encode children with duplicate names" -- assert all 3 children are encoded (2 duplicates + 1 unique)
  - `diff.spec.lua` test 1: Rename to "should not remove real DOM children with duplicate names" -- keep assertion that `removed` is empty (this behavior is unchanged -- we don't remove instances we can't match)
  - `diff.spec.lua` test 2: Rename to "should add virtual children with duplicate names" -- assert both CHILD_A and CHILD_B appear in `patch.added`
- **Risk:** Low -- only test changes, no production code modified
- **Verify round-trip:** N/A (test-only change)
- **Verify syncback parity:** N/A
- **Tests required:**
  - Update encodeInstance.spec.lua test at line 235 (Lua spec)
  - Update diff.spec.lua tests at lines 279, 312 (Lua spec)

### Fix 2: Remove dead code from duplicate-skip removal

- **Status:** Approved
- **Finding:** Step 12: Static analysis (clippy), Step 6: Interactions audit
- **Files:** `plugin/src/ChangeBatcher/encodeInstance.lua`, `plugin/src/Reconciler/diff.lua`, `src/web/api.rs`
- **Problem:** Multiple dead code artifacts:
  - `encodeInstance.lua` line 121: `skippedDuplicateCount` declared but never incremented. Lines 284-296: wrapper function `encodeInstanceWithDuplicateTracking` always sees 0.
  - `diff.lua` lines 19-46: `findDuplicateNames()` defined but never called.
  - `api.rs` line 856: `is_tree_path_unique_with_cache()` -- unused function (clippy warning).
  - `api.rs` line 927: `duplicate_siblings_cache` parameter in `syncback_added_instance` -- unused (clippy warning).
- **Solution:**
  - `encodeInstance.lua`: Remove `skippedDuplicateCount` variable (line 121). Remove the wrapper function `encodeInstanceWithDuplicateTracking` (lines 283-297) and have the module return `encodeInstance` directly. At the `return` statement (line 299), change to `return encodeInstance`. Remove `skippedDuplicateCount` from local scope. NOTE: Callers may depend on the second return value (the count). Grep for all callers and verify.
  - `diff.lua`: Remove `findDuplicateNames` function (lines 19-46). It is not called anywhere in the file after the duplicate-skip removal.
  - `api.rs`: Remove `is_tree_path_unique_with_cache` function (around line 856). Also remove `compute_tree_refs_with_duplicate_siblings` if it's now only used by the removed function. Remove `duplicate_siblings_cache` parameter from `syncback_added_instance` and update all call sites (grep for `syncback_added_instance` and `duplicate_siblings_cache`).
- **Risk:** Medium for encodeInstance.lua (callers depend on return value shape). Low for others.
- **Verify round-trip:** Run full test suite after changes
- **Verify syncback parity:** N/A
- **Tests required:**
  - Verify `cargo clippy --lib` produces no new warnings for changed files
  - Verify existing tests still pass after dead code removal

### Fix 3: Cache redundant find_rbxm_container call

- **Status:** Approved
- **Finding:** Step 4: Server-side processing audit
- **Files:** `src/change_processor.rs`
- **Problem:** Lines 1547-1554 call `tree.find_rbxm_container(id)` twice -- once to check `.is_some()`, then again to destructure the result. Each call walks up the ancestor tree.
- **Solution:** Replace with a single call:

```rust
  let rbxm_container = if instance.metadata().instigating_source.is_none() {
      tree.find_rbxm_container(id)
  } else {
      None
  };

  if let Some((container_ref, rbxm_path)) = rbxm_container {
      rbxm_containers_to_reserialize
          .entry(container_ref)
          .or_insert_with(|| rbxm_path);
  } else {
      // existing property handling code...
  }
  

```

- **Risk:** Very low -- pure refactor, no behavior change
- **Verify round-trip:** Run existing ambiguous container tests
- **Verify syncback parity:** N/A
- **Tests required:**
  - Verify existing tests pass (no new tests needed for refactor)

### Fix 4: Add missing ambiguous_dedup_collision test entry

- **Status:** Approved
- **Finding:** Step 11i: Syncback idempotency / test coverage
- **Files:** `tests/tests/syncback.rs`
- **Problem:** Fixture `rojo-test/syncback-tests/ambiguous_dedup_collision/` exists (generated by fixture generator) but was never added to the `syncback_tests!` macro. The test never runs.
- **Solution:** Add entry to `syncback_tests!` macro in [tests/tests/syncback.rs](tests/tests/syncback.rs):

```rust
  // "Test" (normal dir) and "Te/st" (has duplicates, slugifies to "Test") -> dedup rbxm to Test~1.rbxm
  ambiguous_dedup_collision => [],
  

```

  NOTE: Using empty file list `[]` initially because the exact output filenames depend on processing order (need to verify whether the dir or rbxm claims the "Test" slug first). Run the test, inspect output, then update the file list if possible.

- **Risk:** None -- adding a new test only
- **Verify round-trip:** The test itself verifies round-trip for slug collision
- **Verify syncback parity:** N/A
- **Tests required:**
  - Run test, accept snapshot, verify output is correct (Test/ directory + Test~1.rbxm or vice versa)

### Fix 5: ProjectNode duplicates warn-and-skip instead of bail

- **Status:** Approved (user requested: warn and skip for service AND ProjectNode parents)
- **Finding:** Step 14: Challenge known limitations
- **Files:** `src/snapshot_middleware/project.rs`
- **Problem:** Lines 591-597 (new_child_map duplicate check) and lines 604-610 (old_child_map duplicate check) call `anyhow::bail!` when duplicate-named children are found under a ProjectNode-defined instance. This crashes the entire syncback operation.
- **Solution:** Replace both `bail!` calls with `log::warn!` + `continue` to skip the duplicate children:
  - For `new_child_map` (line 591): When `insert` returns `Some` (duplicate), log a warning with the child name and parent path, then `continue` to skip the duplicate child.
  - For `old_child_map` (line 604): Same treatment.
  - The warning message should be: `"Skipping duplicate-named child '{}' under ProjectNode '{}' -- cannot create rbxm container for project-file instances. Full path: {}/{}"`
  - Unique children continue to sync normally.
- **Risk:** Medium -- changes syncback behavior for a specific error case. Previously this was a hard error; now it's a soft warning with data skip. Users with duplicates under ProjectNode parents will see them silently skipped instead of a crash.
- **Verify round-trip:** Syncback with duplicates under ProjectNode should succeed (warning logged), unique siblings preserved.
- **Verify syncback parity:** N/A (two-way sync already skips ProjectNode modifications)
- **Tests required:**
  - New syncback test fixture `ambiguous_project_node_parent`: ProjectNode service with duplicate children. Verify syncback succeeds, warning is logged, duplicates are skipped, unique children are written.

## Skipped Fixes

None -- all identified fixes were approved.

## Accepted Limitations

- **Limitation:** Plugin reconnection hydration may mismatch duplicate-named instances
- **Scenario:** When plugin reconnects after disconnect, `diff.lua` matches Studio instances to server tree by Name+ClassName. For duplicate-named instances, the ordered matching may pair the wrong sibling.
- **User decision:** Accepted for this release
- **Mitigation:** The next full sync corrects any mismatch. This will be addressed in Phase 2 (N-to-M property-based matcher).

## Deferred Refactors

- **Consolidate rbxm container detection logic**: `find_rbxm_container` is called from `api.rs`, `change_processor.rs`, and potentially `syncback/mod.rs`. The "is this instance inside an rbxm container?" check pattern appears in multiple places with slight variations. Consider a higher-level API that returns an enum of `NotInContainer | IsContainer(path) | InsideContainer(container_ref, path)`.
- `**encodeInstance.lua` dead helpers**: `findDuplicateNames`, `hasDuplicateSiblings`, `isPathUnique` are all still defined and called for debug logging but never used for filtering. If the server reliably handles all duplicates, these could be stripped entirely to reduce plugin complexity. Evaluate after Phase 2 N-to-M matching.

## Test Plan

### Lua Spec Tests (`.spec.lua` files)

- Update `encodeInstance.spec.lua` "should skip children with duplicate names" to assert all children encoded (Fix 1)
- Update `diff.spec.lua` "should skip real DOM children with duplicate names" to assert correct new behavior (Fix 1)
- Update `diff.spec.lua` "should skip virtual children with duplicate names" to assert both added (Fix 1)

### Rust Integration Tests (`tests/tests/`)

- Add `ambiguous_dedup_collision` entry to `syncback_tests!` macro, accept snapshot (Fix 4)
- Add `ambiguous_project_node_parent` syncback test: ProjectNode service with duplicate children, verify unique children sync and duplicates are warned/skipped (Fix 5)

### Static Analysis

- Verify `cargo clippy --lib` produces 0 warnings in `api.rs` (after Fix 2 dead code removal)
- Verify `cargo test --lib` passes all 707+ unit tests
- Verify `cargo test --test end_to_end` passes all 418+ integration tests

## Test Rules

The implementer MUST follow these rules when writing tests for this plan:

### For bugs found and fixed

Every bug fix MUST have a test that:

1. Would have **FAILED** before the fix
2. **PASSES** after the fix
3. Prevents the bug from regressing

### For missing coverage identified

For each "missing test coverage" gap:

1. Write the test
2. Verify it passes against the current implementation
3. If it fails, investigate -- it may have found another bug

### For known limitations (Accepted Limitations section)

For each known limitation that violates round-trip identity:

1. Write a test that asserts the **correct** behavior
2. The test SHOULD FAIL against the current implementation
3. **Leave the test failing** -- do NOT mark it `#[ignore]` or fix the implementation

### Scope: test every affected layer

For each finding, determine which test layers are affected and write tests in ALL of them.

## Final Step: Run CI

After ALL fixes and tests are implemented, run the `/ci` command to execute the full CI pipeline. Every fix must pass CI before the plan is considered complete.